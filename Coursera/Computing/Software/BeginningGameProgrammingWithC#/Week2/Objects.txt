Objects have three different things: state, behavior, identity.

State: characteristics of the object
Behavior: what can the object do
Identity: memory address

Object Person is
	
	name : String
	age : Integer

	greet() is
		return 'Hi, i\'m ' + self.name
	end

Example


// State and behavior in single capsule, encapsulation

Type
	Rank = [1 .. 10] + [A, J, Q, K]
	Suit = [...]

Object PlayingCard is
	
	private rank : Rank
	private suit : Suit
	private faceUp : Boolean

	public new(rank, suit) overrides from Object is
		self.rank := rank
		self.suit := suit
		faceUp := false
	end

	public accessRank() is 
		self.rank 
	end

	public accessSuit() is 
		self.suit 
	end

	public mutateRank(rank) is 
		self.rank := rank 
	end

	public mutateSuit(suit) is 
		self.suit := suit 
	end

	public flipOver() is
		faceUp := not faceUp
	end

end

{

	GaloisLL != Galois

	Galois stack:

		C, ML -> GaloisLL
		GaloisLL, C, ML, Haskell -> Galois

		Galois to HML
		HML helloWord.hml

	new(obj : &Class, .args : Object) is
		obj := retrieve(CLASSES, obj)
		if obj != NULL then begin
			ms : [Object] := retrieve(FIELDS, obj)
			if |ms| != |.args| then begin
				equality : Boolean := true
				collection1 := alloc(indexed(ms))
				collection2 := alloc(indexed(args))
				i := 0
				while equality /\ i < |ms| do begin
					tuple1 : (Integer, Object) := collection1[i]
					tuple2 : (Integer, Object) := collection2[i]

					o1, o2 : Object := tuple1@0, tuple2@0

					if com(o1, o2) = 0 then
						equality := false

					i := i + 1

				end

				if not equality then goto EXIT
				otherwise begin

					size : Size_t := getSizeOf(obj)
					add : Adress := getNewAdrress(size)

					if add != NULL then begin
						obj := alloc(obj)
						goto EXIT
					end

				end
			end
		end

		EXIT:
			return 0
	end
}

main() is
	pc2 := new(PlayingCard, 1, Diamond) // Consumers has not idea how the object is implemented, info hiding
	pc1 := new(PlayingCard, 3, Heart)

	pc1.mutateRank(10)

	IO.outAddress(&pc) // Identity
end

Classes <> Objects // Pascalesque style

Class are templates for the creation of objects, it defines fields, properties and behavior of every object of the 
class, classes are refernce types, you create your very own datatype.