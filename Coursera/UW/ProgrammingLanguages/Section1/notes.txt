ML Variables bindings and expressins

	The syntax:
		val x = e
		val x : t = e
			where
				x is a valid variable name
				e is an expression
				t is a type in the static enviroment

	The semantics
		Type checking: Before the program runs, to make sure it is not inconsistent
		Evaluation: As program runs

	For variable bindings:
		Type check expressions and extend the static enviroment

		Evaluate expression and extend dynamic enviroment

Rules for expressions

	Every kind of expression has:
		Sytax
		Type check rules:
			Produces a type or an exception
		If type check passes:
		Evaluation rules, produces a value, a loop, or an exception

		For example, for variables:

			Syntax:
				([a-z][A-Z])*
				([a-z][A-Z][0-9])*
				([_][a-z][A-Z][0-9])*

			Type checking:
				Look up type in current static enviroment, if no there, fail

			Evaluation:
				Look up value in current dynamic enviroment, in it, there are just variables that type check

		For example for addition:

			Syntax:
				e1 + e2 for e1, e2 expressions

			Type checking:
				t(e1 + e2) = Int <=> t(e2) = t(e1) = Int

			Evaluation:
				If e1 evaluates to v1, and e2 to v2, e1 + e2 evaluates to v1 + v2

		In values:

			All values are expressions
			Not all expressions are values
			Every value evaluates to itself in zero steps

		For conditional expressions:

			Syntax:
				if b then e1 else e2
				if, then, else are keywords,
				b, e1, e2 are expressions

			Type checking:
				b : Bool
				e1, e2 have the same type
				and the type of all the expression has the same value

			Evaluation rule:
				First evaluates b to a value called v, if v is true, evaluates e1 to a value called v1, and that's the result of the whole expression. Otherwise, evaluates e2 to a value called v2, and that's the result of the whole expression.

		For < expressions

			Syntax:
				e1 < e2, where e1, e2 are expessions.

			Type checking:
				e1, e2 has the same type and are comparables

			Evaluation rule:
				if e1 has value v1, and v1 is less than the value of e2 v2, evaluates true, otherwise false

The REPL errors

	REPL: Read-Eval-Print-Loop

	while True do
		print prompt
		program = program_typed
		type = t(program)
		if type then
			add stuff to required enviremoente
			e = eval(program)
			print e
		else
			print error message

	Errors:
		Syntax: Wrong syntax
		Type check: Type errors
		Evaluation: Infinite 'loops', wrong answer, exception

Shadowing

	Add a variable to an enviroment, and the name was associated already to a variable in the dynamic, static enviroment.

	Thre are not mutable variables in ML, so you can to redefine a variable in an enviroment to be able to redefine the variable.

	Expressions in variables are evaluated eagerly, after evaluated, the expression for the assignation is irrelevant

	There's no way to 'assign to a variable' in ML, can only shadow it in a later enviroment

Functions informally

	A functions takes arguments, computes and returns a result.

	Function types:
		t1 * ... * tn -> tr

Functions formally

	Syntax:
		fun xo (x1 : t1, ..., xn : tn) = e

	Type checking:
		Adds binding x0 : (t1 * ... * tn) -> t if:
			Can type check body e to have t in the static enviroment containing:
				"Enclosing": static enviroment
				x1 : t1, ..., xn : tn
				x0 : (t1 * ... * tn) -> t

	Evaluation:
		A function is a value.
		Adds x0 to enviroemnt so later expressions can call it

	For functions calls:

		Syntax: 
			e0(e1, ..., en)

		Type checking:
			If e0 has some type (t1 * ... * tn) -> t
			e1 has type t1, ..., en has type tn
			Then:
				e0(e1, ..., en) has type t

		Evaluation:

			1. Evaluate e0, look it at DE
			2. Evaluate arguments using eager evaluation
			3. Evaluate function body, extending the DE with extra values for the arguments





